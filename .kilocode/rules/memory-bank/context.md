# SousChefy - Context

## Current State

SousChefy is a fully functional voice-controlled grocery shopping application built with React 18, TypeScript, and Vite. The application is currently in a stable state with all core features implemented and working.

## Recent Work

The project has been recently initialized with a comprehensive implementation including:

- **Core Application**: Complete voice recognition system with dual-mode operation (Adding and Shopping modes)
- **Speech Recognition**: Custom hook (`useSpeechRecognition`) with mobile optimizations and aggressive stop mechanisms
- **Grocery Database**: Comprehensive database of 200+ items across 14 categories with fuzzy matching
- **UI Components**: Full implementation using shadcn/ui components with Tailwind CSS styling
- **Routing**: React Router setup with Landing Page, Main App, and 404 handling
- **Mobile Microphone Fix (2025-12-27)**: Fixed critical issue where microphone wouldn't stop on mobile after clicking "Stop Adding". Added `forceStoppedRef` to prevent unwanted restarts and updated all event handlers to use synchronous refs instead of async state.
- **List and Recipe Deletion (2026-01-17)**: Fixed list deletion to also delete from database. Previously, lists were only removed from localStorage/state but persisted in database. Updated `deleteList` function in GroceryApp to call `listsApi.delete()` with graceful error handling for offline/local-only lists. Recipe deletion was already working correctly.
- **ChefAI List Creation (2026-01-17)**: Enabled ChefAI to create shopping lists for users. Users can now tell ChefAI what they need (e.g., "I need milk, eggs, and bread"), and ChefAI will:
  - Parse the request using OpenAI
  - Extract grocery items with quantities and units
  - Switch to "Make a List" tab automatically
  - Add items to the shopping list
  - Provide confirmation via toast notification
  - Support both append and replace list operations
- **Chat Interface Redesign (2026-01-18)**: Redesigned chat interface from modal to inline panel. Chat bubble moved from bottom-right to top-right corner and changed to green. Chat panel now opens inline on the page (between header and main content) instead of as a modal overlay. Features include:
  - Green chat bubble positioned at top-right corner
  - Inline collapsible chat panel (no longer a modal)
  - Compact height: 280px mobile, 320px desktop
  - Removed header bar for more space-efficient design
  - Auto-scrolling when panel opens and when new messages arrive
  - Smooth expand/collapse animation with 300ms duration
  - Voice input support with Web Speech API integration
  - Auto-send on silence (3 seconds of no speech)
  - Streaming responses from ChefAI for real-time feedback
- **ChefAI Recipe Saving and History Access (2026-01-18)**: Enhanced ChefAI with comprehensive new capabilities:
  - **Recipe Saving**: ChefAI can now save recipes directly from conversations
    - Users can ask ChefAI to save any recipe it generates or recommends
    - Recipes are saved to the database and appear in Saved Recipes tab
    - Full integration with existing recipe management system
    - Confirmation messages and toast notifications provide feedback
    - Support for both authenticated and unauthenticated users
  - **Shopping History Access**: ChefAI now has access to user's complete shopping history
    - ChefAI can view all past shopping lists (up to last 5 lists in context)
    - Shopping history includes list names, item counts, and item previews
    - Enables ChefAI to make personalized recommendations based on shopping patterns
    - Shopping history is summarized in ChefAI context to manage token limits
    - Supports personalized meal planning based on historical shopping data
    - Enables ChefAI to understand user preferences and shopping habits
    - Full integration with existing shopping list management system
- **ChefAI Recipe Options and Tab Switching (2026-01-18)**: Enhanced ChefAI with recipe display capabilities:
  - **Recipe Options Mode**: When users ask for recipe ideas ("What can I cook?", "Give me recipe ideas"), ChefAI generates 5 recipe options with names and brief descriptions
    - Automatically switches to Recipe tab
    - Shows recipes in "options" mode (compact cards with names and descriptions)
    - Displays blue indicator banner showing recipe source
    - Users can click on recipes to view full details
  - **Full Recipe Mode**: When users ask for specific recipes ("Give me a lasagna recipe", "How do I make chicken stir fry?"), ChefAI generates complete recipes
    - Automatically saves recipe to user's collection
    - Automatically switches to Recipe tab
    - Opens full recipe detail view immediately
    - Includes all recipe details: ingredients, instructions, prep time, cook time, servings, difficulty
  - **External Recipes Integration**: RecipeTab now supports external recipes from ChefAI
    - `externalRecipes` prop accepts recipes generated by ChefAI
    - `externalMode` prop distinguishes between 'options' and 'full' modes
    - `onClearExternalRecipes` callback allows users to clear ChefAI suggestions
    - Blue indicator banner shows recipe source and provides clear button
    - Seamless integration with existing recipe search functionality
- **ChefAI Redesign: Short Responses & Tab Routing (2026-01-18)**: Completely redesigned ChefAI behavior for cleaner, more focused user experience:
  - **One-Sentence Responses**: All ChefAI responses now limited to one sentence maximum
    - Examples: "Added to your list.", "Check Recipe tab.", "Recipe saved. Check Cooking tab."
    - No detailed item listings in chat
    - No recipe details in chat
    - No multi-paragraph responses
  - **Tab-Based Routing**: Different request types automatically route to appropriate tabs
    - **List requests** (add/remove items) → Switch to Home tab
    - **Recipe ideas** ("What can I cook?") → Switch to Search tab with 5 recipe options
    - **Cooking requests** (specific recipes) → Switch to Cooking tab with full recipe
    - **History requests** ("Show my history") → Switch to Favorites tab
    - **General questions** → Answer in chat with one sentence, no tab switch
  - **New Functions**:
    - `show_recipe_in_cooking_tab`: Saves recipe to database and switches to Cooking tab
    - `switch_to_history_tab`: Switches to Favorites/History tab
  - **Clean Chat Interface**:
    - Removed all chat confirmation messages (e.g., "I've added 3 items to your list...")
    - Toast notifications provide all feedback
    - Chat only shows one-sentence AI responses
  - **Updated Components**:
    - `ChatPanel`: Added new function handlers and removed chat confirmations
    - `GroceryApp`: Added new callbacks for tab switching
    - `CookingMode`: Updated to accept `selectedRecipe` prop for direct recipe display

## Current Focus

The application is feature-complete for its core functionality. All major features are implemented:

1. Voice input for adding items with natural language processing
2. Shopping mode for hands-free item check-off
3. Category-based item organization with emoji display
4. Shopping list history management (save/load up to 10 lists)
5. Keyboard shortcuts (A for add, S for shop, Escape to stop)
6. Mobile-optimized speech recognition
7. Celebration system with audio feedback
8. AI-powered recipe generation using OpenAI API
9. Recipe saving and management capabilities
10. Manual recipe search by dish name or ingredients

## Known Technical Considerations

### Speech Recognition Challenges

- **Mobile Quirks**: Mobile browsers have different speech recognition behavior requiring special handling
- **Microphone Control**: Multiple stop mechanisms needed to ensure microphone stops reliably (up to 200ms timeout)
- **Race Condition Fix**: Event handlers now use synchronous refs (`isListeningRef.current`, `forceStoppedRef.current`) instead of async state to prevent microphone restarts
- **Auto-Stop Timeout**: 3-second timeout for adding mode to prevent no-speech errors
- **Continuous Listening**: Shopping mode has no timeout to allow indefinite operation

### Performance Optimizations

- **Debounced Processing**: 500ms debounce on transcript processing to avoid excessive re-renders
- **Aggressive Cleanup**: Multiple timeout clears and stop calls to prevent memory leaks
- **State Management**: Proper cleanup on mode changes and component unmount
- **Callback Memoization**: `useCallback` for event handlers
- **Computed Values**: `useMemo` for expensive calculations
- **Context Management**: Shopping history limited to last 5 lists in ChefAI context to manage token limits

### Performance Bottlenecks

1. **Grocery Database Lookup**: O(n) search through 200+ items (acceptable for current scale)
2. **Speech Recognition**: Browser-dependent performance
3. **Large Shopping Lists**: Rendering performance with 100+ items
4. **ChefAI Context**: Shopping history summary adds to context size

## Security Considerations

1. **Microphone Permissions**: Requires user consent
2. **No External APIs**: All processing happens in-browser
3. **No Data Persistence**: Lists stored in memory only (history in localStorage)
4. **HTTPS Required**: Speech API requires secure context
5. **Database Security**: All data operations are user-specific (filtered by userId in backend)
6. **Recipe Security**: Recipes are user-specific with ownership verification

## Browser Compatibility

### Supported Browsers

- **Chrome/Edge** (full support)
- **Safari** (partial support, different behavior)
- **Firefox** (limited support)

### Mobile Considerations

- **iOS Safari**: Different speech recognition behavior
- **Android Chrome**: Generally good support
- **Requires special handling for mobile quirks**

## Next Steps

The application is feature-complete for its core functionality. Potential areas for future enhancement:

1. **Testing**: Add unit and integration tests for speech recognition logic
2. **Error Handling**: Improve error recovery for speech recognition failures
3. **Offline Support**: Consider PWA capabilities for offline usage
4. **Analytics**: Add usage tracking to understand user behavior
5. **Internationalization**: Support for multiple languages
6. **Cloud Sync**: Backend integration for cross-device list synchronization
7. **Advanced Recipe Features**: Meal planning, recipe variations, shopping list templates

## Development Environment

- **Node.js**: Required for development (version 18+)
- **Package Manager**: npm (package-lock.json present)
- **Build Tool**: Vite with React SWC plugin for fast compilation
- **Dev Server**: Runs on port 8080 with host "::"
- **Linting**: ESLint with TypeScript support
- **Styling**: Tailwind CSS, shadcn/ui component library

## Deployment

The application is ready for deployment with:

- **Production Build**: Configured via `npm run build`
- **Static Site Hosting**: Compatible with any static hosting service (Vercel, Netlify, GitHub Pages, Cloudflare Pages, AWS S3 + CloudFront)
- **No Backend Server Required**: All processing happens in-browser with no external service dependencies
- **HTTPS Required**: Speech API requires secure context
- **No API Keys Required**: Browser-native APIs only (no external service dependencies)

### Deployment Checklist

1. Build application: `npm run build`
2. Upload `dist/` directory to hosting service
3. Ensure HTTPS is enabled
4. Test microphone permissions
5. Test speech recognition functionality
6. Test ChefAI recipe saving and history access
7. Verify recipe persistence to database
8. Test shopping list management
9. Verify shopping history access

## Technical Constraints

### Browser Support

- **Chrome/Edge**: Full support for Web Speech API
- **Safari**: Partial support, different behavior
- **Firefox**: Limited support

### Mobile Considerations

- **iOS Safari**: Different speech recognition behavior
- **Android Chrome**: Generally good support
- **Requires special handling for mobile quirks**

## Architecture Summary

SousChefy follows a component-based architecture with clear separation of concerns:

- **Frontend**: React 18, TypeScript, Vite, Tailwind CSS, shadcn/ui
- **Backend**: Express.js with Prisma ORM (PostgreSQL database)
- **APIs**: RESTful APIs for lists, recipes, and authentication
- **State Management**: Local component state with localStorage fallback
- **Speech Recognition**: Web Speech API with custom hook
- **ChefAI**: OpenAI integration with function calling support

The system is production-ready and follows modern best practices for React applications.

### New Capabilities

1. **Recipe Saving**: Users can ask ChefAI to save any recipe
   - Example: "Save this recipe", "Remember this pasta dish"
   - ChefAI will parse recipe details and save to database
   - Confirmation message appears in chat
   - Toast notification confirms successful save
   - Recipe appears in Saved Recipes tab
   - Full integration with existing recipe management system

2. **Shopping History Access**: ChefAI can now access and reference shopping history
   - ChefAI can view all past shopping lists (up to last 5 lists)
   - Shopping history includes list names, item counts, and item previews
   - Enables ChefAI to make personalized recommendations based on shopping patterns
   - Shopping history is summarized in ChefAI context to manage token limits
   - Supports personalized meal planning based on historical shopping data
   - Enables ChefAI to understand user preferences and shopping habits

### User Experience Improvements

- **More Personalized Interactions**: ChefAI can now provide context-aware responses
- **Better Recommendations**: ChefAI can suggest recipes based on user's shopping habits
- **Seamless Recipe Management**: Users can save recipes directly from chat without leaving the chat interface
- **Complete Shopping History**: All past lists are accessible to ChefAI for smarter assistance

## Implementation Summary

Recipe generation functionality has been successfully implemented and tested:

1. **OpenAI Integration**: Added recipe generation functions (`generateRecipeByDish`, `recommendRecipesByIngredients`)
2. **Type Definitions**: Created `Recipe` and `RecipeIngredient` interfaces in openai.ts
3. **RecipeTab Component**: Updated to use OpenAI API for recipe search
4. **Error Handling**: Comprehensive error handling for API failures
5. **User Feedback**: Toast notifications for success and error states

## Testing Results

- ✅ Build completed successfully with no TypeScript errors
- ✅ Recipe generation by dish name works correctly
- ✅ Recipe recommendations by ingredients work correctly
- ✅ Error handling implemented for all edge cases
- ✅ Toast notifications provide user feedback
- ✅ Loading states displayed during API calls

## Next Steps

The implementation is complete and ready for use. Users can now:

1. Generate recipes by dish name
2. Get recipe recommendations based on available ingredients
3. Save generated recipes to their collection
4. Add recipe ingredients to shopping list with one click
